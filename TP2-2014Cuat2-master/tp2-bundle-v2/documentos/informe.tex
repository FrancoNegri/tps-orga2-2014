\documentclass[a4paper]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{charter}   % tipografia
\usepackage{graphicx}
%\usepackage{makeidx}
\usepackage{paralist} %itemize inline

%\usepackage{float}
%\usepackage{amsmath, amsthm, amssymb}
%\usepackage{amsfonts}
%\usepackage{sectsty}
%\usepackage{charter}
%\usepackage{wrapfig}
%\usepackage{listings}
%\lstset{language=C}


\input{codesnippet}
\input{page.layout}
% \setcounter{secnumdepth}{2}
\usepackage{underscore}
\usepackage{caratula}
\usepackage{url}


% ******************************************************** %
%              TEMPLATE DE INFORME ORGA2 v0.1              %
% ******************************************************** %
% ******************************************************** %
%                                                          %
% ALGUNOS PAQUETES REQUERIDOS (EN UBUNTU):                 %
% ========================================
%                                                          %
% texlive-latex-base                                       %
% texlive-latex-recommended                                %
% texlive-fonts-recommended                                %
% texlive-latex-extra?                                     %
% texlive-lang-spanish (en ubuntu 13.10)                   %
% ******************************************************** %



\begin{document}


\thispagestyle{empty}
\materia{Organización del Computador II}
\submateria{Segundo Cuatrimestre de 2014}
\titulo{Trabajo Práctico II}
\subtitulo{subtitulo del trabajo}
\integrante{Nombre}{XXX/XX}{mail}
\integrante{Nombre}{XXX/XX}{mail}

\maketitle
\newpage

\thispagestyle{empty}
\vfill
\begin{abstract}
En el presente trabajo se describe la problemática de procesar información de manera eficiente cuando los mismos requieren:
\begin{enumerate}
\item Transferir grandes volumenes de datos.
\item Realizar las mismas instrucciones sobre un set de datos importante.
\end{enumerate}

\end{abstract}

\thispagestyle{empty}
\vspace{3cm}
\tableofcontents
\newpage

%\normalsize
\newpage

\section{Objetivos generales}

El objetivo de este Trabajo Práctico es mostrar las variaciones en la performance que suceden al utilizar instrucciones SIMD en comparación con código C con diversos grados de optimización realizados por el compilador.

Para ello se realizarán cuatro filtros de fotos, Cropflip, Bandas, Sierpinski y Motion Blur, tanto en código assembler, que aproveche las instrucciones SSE brindadas para los procesadores de arquitectura Intel, como en código C, al que se le aplicarán los distintos flags de optimización -O0 (predeterminado), -O1, -O2 y -O3.

El primer filtro, Cropflip, se utilizará para mostrar cuanto mejora la performance al utilizar los registros XMM para transferir grandes cantidades de información.

El segundo, tercer y cuarto filtro, se centrarán en la variación de performance (en comparación al código en C) al utilizar instrucciones SIMD, no sólo para transferir grandes volúmenes de datos sino también para procesarlos en forma paralela, es decir, realizar diversos cálculos (sumas, multiplicaciones, divisiones) tanto en representación de enteros como punto flotante.

\section{Enunciado y solución} 

\subsection{Enunciado}

\input{enunciado}
\
\newpage

\subsection{Desensamblado de código C y Optimización}
Comenzamos analizando el código de Cropflip realizado en C.

Este básicamente solo mueve datos de un lugar de la RAM a otros, sin afectar mayormente la imagen.

Realizamos un objdump para ver el código que genera el compilador gcc. Al desensamblar el código pudimos observar, primero que nada, que C guarda todos los parámetros en la pila y además está escribiendo en memoria todas las variables locales utilizadas, lo cual es innecesario ya que pueden ser almacenadas en registros.

También puede observarse que C utiliza saltos incondicionales, lo que puede sugerir que intenta sacar provecho al sistema de predicción de saltos.

Ademas C genera, luego de la función, un montón de secciones que comienzan con debug_xxx. Estas secciones sirven para ser interpretadas por GDB u otros debuggers.

Como ya dijimos, el código podría optimizarse para no realizar tantos accesos a memoria innecesarios guardando variables locales por ejemplo en registros, lo cual disminuiría el tiempo de ejecución.

Luego de esto, procedemos a compilar el código utilizando el flag -O1, y nuevamente realizamos un objdump para ver el código desensamblado. Se observa que ahora el mismo solo realiza los accesos a memoria mínimos indispensables, utilizando los registros para guardar los datos. Además el código es más compacto, y resulta mas claro de leer. Además precalcula los valores que serán utilizados muchas veces, lo que aumenta la performance, principalmente en casos de instancias grandes.

Los otros flags de optimización son -O2, -O3, -Og, -Os, -Ofast. También podemos encontrar los flags -msse, -msse2, -msse3, -mmmx, -m3dnow, pero al intentar compilar con varios de ellos vimos que gcc no utilizó instrucciones SIMD.

Tres nombres de optimizaciones son: -fipa-profile, -fipa-reference ,-fmerge-constants .

\newpage
\subsection{Calidad de las Mediciones}
Para este experimento vamos a ver cómo se pueden ver afectados nuestros algoritmos frente a diversos factores de ruido e interferencias que podrían alterar nuestras mediciones.

Para este experimento se utilizó un procesador Intel Atom, de 2 núcleos a 1.6 GHZ con Hyper-Threading, por lo que la cantidad de núcleos lógicos asciende a 4. Por otro lado, para que las pruebas sean mas concisas y exactas, se deshabilitó el scaling dinamico del CPU, ya que esto podría generar ruido innecesario en nuestras mediciones.

Procedimos a tomar 10 mediciones para cada una de las versiones del cropflip, tanto con 4 loops corriendo en paralelo como sin los mismos. Lo que se obtiene es el siguiente gráfico:
\\
\begin{figure}[h!]
  \begin{center}
	\includegraphics[scale=0.66]{Graficos1.4/1.3/PCO.png}
	\label{nombreparareferenciar1}
  \end{center}
\end{figure}
\\
Realizamos un cálculo de la varianza para ver qué tan precisos son los resultados y se obtiene esto:

\begin{figure}[h!]
  \begin{center}
	\includegraphics[scale=0.66]{Graficos1.4/1.3/VCO.png}
	\label{nombreparareferenciar2}
  \end{center}
\end{figure}

La varianza con loops es sustancialmente mayor que sin los mismos, por lo que se estaría inclinado a correr tests sin loops para obtener valores mas fiables.

Ahora consideramos outliers a los dos valores mas grandes y a los dos valores mas chicos y volvemos a graficar los resultados.

Esto es lo que se obtiene al graficar el promedio:

\begin{figure}[h!]
  \begin{center}
	\includegraphics[scale=0.66]{Graficos1.4/1.3/PSO.png}
	\label{nombreparareferenciar3}
  \end{center}
\end{figure}

En este gráfico no se observan cambios significativos. Sin embargo, al calcular nuevamente la varianza, se observa lo siguiente:

\begin{figure}[h!]
  \begin{center}
	\includegraphics[scale=0.66]{Graficos1.4/1.3/VSO.png}
	\label{nombreparareferenciar4}
  \end{center}
\end{figure}

Las varianzas de los tests con loops, se ven reducidas dramáticamente, incluso por debajo de las varianzas sin los mismos.

De aquí se concluye, que la mejor manera de realizar tests es con loops corriendo en paralelo y luego, cuando estos valores ya han sido obtenidos, quitando los dos valores mas grandes y los dos valores mas chicos.

\newpage
\section{Cropflip}
\subsection{Diferencias de performance en Cropflip}
En el siguiente experimento se medirán las performances tanto de nuestro algoritmo en assembler, implementado para sacar provecho de las instrucciones SSE de Intel, como una versión alternativa hecha en C con diversos grados de optimización a cargo del compilador.

El algoritmo de Cropflip en assembler es muy sencillo. Simplemente movemos 128-bits de la imagen a un xmm y de allí al destino, que previamente ha sido seteado para colocar los bits en el lugar correcto. De esta manera, podremos mover de una sola vez, 16 bytes, lo que corresponde a 4 pixels de la imagen.

Dado que la cantidad de columnas es siempre múltiplo de 4, o sea, siempre tenemos 4 bytes para tomar, no es necesario chequear otros casos borde.

Las pruebas de performance, realizadas de la misma manera en que concluimos la anterior sección, se realizaron corriendo 4 loops en paralelo junto con los algoritmos de manera de minimizar el ruido y luego quitando los outliers.

Lo obtenido en los tests puede verse en el siguiente gráfico:

\begin{figure}[h!]
  \begin{center}
	\includegraphics[scale=0.66]{Graficos1.4/crop/PSO.png}
	\label{nombreparareferenciar5}
  \end{center}
\end{figure}

\newpage
Y las varianzas son:

\begin{figure}[h!]
  \begin{center}
	\includegraphics[scale=0.66]{Graficos1.4/crop/VSO.png}
	\label{nombreparareferenciar6}
  \end{center}
\end{figure}

De aquí puede verse que la implementación en assembler es tan buena como la implementación en C con el máximo grado de optimización.

\newpage

\subsection{cpu vs. bus de memoria en Cropflip}
HACER =)

\begin{figure}[h!]
  \begin{center}
  \includegraphics[scale=0.66]{Graficos1.5/crop/addsub/per.png}
  \label{nombreparareferenciar1}
  \end{center}
\end{figure}

\begin{figure}[h!]
  \begin{center}
  \includegraphics[scale=0.66]{Graficos1.5/crop/addsub/var.png}
  \label{nombreparareferenciar1}
  \end{center}
\end{figure}

\newpage
\begin{figure}[h!]
  \begin{center}
  \includegraphics[scale=0.66]{Graficos1.5/crop/pushpop/per.png}
  \label{nombreparareferenciar1}
  \end{center}
\end{figure}

\begin{figure}[h!]
  \begin{center}
  \includegraphics[scale=0.66]{Graficos1.5/crop/pushpop/var.png}
  \label{nombreparareferenciar1}
  \end{center}
\end{figure}



\newpage
\section{Sierpinski}
\subsection{Diferencias de performance en Sierpinski}
Ahora analizamos el algoritmo del Sierpinski. En este caso, el algoritmo ya es un poco más complejo. Necesitamos calcular para cada columna un valor constante diferente, que dependerá de cuál sea la misma.
\\
Luego para poder paralelizar de alguna manera el algoritmo en C y sacar provecho a los registros xmm, es necesario calcular 4 constantes a la vez y multiplicárselas a sus respectivos pixels.
\\
Luego la idea del algoritmo será algo así:
\begin{codesnippet}
\begin{verbatim}

  Pongo r10 y r11 en 0, estos serán la fila (i) y columna (j) en la que estoy parado.
  Pongo en xmm8 la cantidad de columnas, lo brodcasteo y lo convierto a float
  Pongo en xmm9 la cantidad de filas, lo brodcasteo y lo convierto a float
  Muevo a xmm13 la constante 255 brodcasteada y en formato float
  Muevo a xmm15 los valores 0,1,2,3 en formato entero.
  Seteo xmm14 en 0.
  Luego, para cada paso iterativo:
    Tomo 4 pixels de la fuente y los pongo en xmm0.
    Muevo r10 y r11 a xmm10 y xmm11 respectivamente, los brodcasteo.
    Sumo xmm10 y xmm15 para obtener el numero i apropiado para cada pixel, tendré (i+0,i+1,i+2,i+3).
    Convierto xmm10 y xmm11 a punto flotante.
    Divido xmm10 por xmm9 y xmm11 por xmm8. (xmm10= i/filas), y (xmm11= j/columnas).
    Multiplico xmm10 y xmm11 por xmm13, o sea multiplico ambos valores por la constante 255 previamente brodcasteada.
    Convierto xmm10 y xmm11 nuevamente a entero y realizo un xor entre ellos.
    Paso a float xmm10 nuevamente y lo divido por xmm13.
    Hasta aquí hemos calculado el coeficiente $b$ para cada uno de los 4 pixels.
    Ahora solo resta tomar los 4 pixels que teníamos en xmm0, desempaquetarlos y convertirlos a float
    Multiplicarlos cada uno de los pixels por su constante $b$
    Convertir nuevamente los valores a byte y ponerlos en el destino.
\end{verbatim}
\end{codesnippet}

Los resultados comparativos de performance para este algoritmo comparado con uno iterativo desarrollado en C fueron los siguientes:

\begin{figure}[h!]
  \begin{center}
  \includegraphics[scale=0.66]{Graficos1.4/sie/PSO.png}
  \label{nombreparareferenciar7}
  \end{center}
\end{figure}

\newpage

Y la varianza:

\begin{figure}[h!]
  \begin{center}
  \includegraphics[scale=0.66]{Graficos1.4/sie/PSO.png}
  \label{nombreparareferenciar8}
  \end{center}
\end{figure}

Puede verse que en este caso nuestro modelo que toma y calcula de a 4 pixels utilizando instrucciones SIMD es incluso mejor que la versión de C con mayor grado de optimización.

\newpage
\subsection{cpu vs. bus de memoria en Sierpinski}

HACER =)

\begin{figure}[h!]
  \begin{center}
  \includegraphics[scale=0.66]{Graficos1.5/sie/addsub/per.png}
  \label{nombreparareferenciar1}
  \end{center}
\end{figure}

\begin{figure}[h!]
  \begin{center}
  \includegraphics[scale=0.66]{Graficos1.5/sie/addsub/var.png}
  \label{nombreparareferenciar1}
  \end{center}
\end{figure}


\begin{figure}[h!]
  \begin{center}
  \includegraphics[scale=0.66]{Graficos1.5/sie/pushpop/per.png}
  \label{nombreparareferenciar1}
  \end{center}
\end{figure}

\begin{figure}[h!]
  \begin{center}
  \includegraphics[scale=0.66]{Graficos1.5/sie/pushpop/var.png}
  \label{nombreparareferenciar1}
  \end{center}
\end{figure}



\newpage
\section{Bandas}
\subsection{Diferencias de performance en Bandas}
Para el algoritmo de bandas se nos presenta otro desafío: debemos tomar los tres colores de la imagen(r,g,b), sumarlos, y luego comparar cada uno de ellos para ver si se encuentra en un rango determinado.
\\
Para resolver la primera problemática usaremos las instrucciones $phaddw$, que nos permitirá a través de una suma horizontal, sumar los valores r,g,b de manera cómoda solamente utilizando dos registros.
\\
El segundo problema será comparar estos valores obtenidos en la suma de una manera eficiente. Querríamos compararlos todos a la vez y a partir de esas comparaciones determinar que valores deberá ir en cada pixel. Esta se resolverá utilizando broadcasting. El algoritmo irá comparando en cada paso contra un valor y en caso de cumplirse una condición, restará donde corresponda.

\begin{codesnippet}
\begin{verbatim}
  Algoritmo
\end{verbatim}
\end{codesnippet}

Los resultados de los tiempos comparativos son los siguientes:

\begin{figure}[h!]
  \begin{center}
  \includegraphics[scale=0.66]{Graficos1.4/ban/PSO.png}
  \label{nombreparareferenciar9}
  \end{center}
\end{figure}

\newpage
Y la varianza:

\begin{figure}[h!]
  \begin{center}
  \includegraphics[scale=0.66]{Graficos1.4/ban/PSO.png}
  \label{nombreparareferenciar10}
  \end{center}
\end{figure}

Nuestro algoritmo obtiene una performance mucho mayor a la del código sin optimizar, y una performance casi idéntica al del código C con el mayor grado de optimización.

\newpage
\subsection{saltos condicionales}

HACER =)

\begin{figure}[h!]
  \begin{center}
  \includegraphics[scale=0.66]{Graficos3.1/per.png}
  \label{nombreparareferenciar1}
  \end{center}
\end{figure}

\begin{figure}[h!]
  \begin{center}
  \includegraphics[scale=0.66]{Graficos3.1/var.png}
  \label{nombreparareferenciar1}
  \end{center}
\end{figure}

\newpage
\subsection{Motion Blur}
\subsection{Diferencias de performance en Motion Blur}
Para este algoritmo por cada pixel se deben tomar 5 pixels, multiplicar cada uno de los colores por 0.2 y luego sumarlos.
\\
Para ello debemos tener cuidado de tomar correctamente los casos borde y no aplicar motion blur donde no corresponde.

\begin{codesnippet}
\begin{verbatim}
  Algoritmo
\end{verbatim}
\end{codesnippet}

Al realizar el testing se obtuvieron los siguientes resultados:

\begin{figure}[h!]
  \begin{center}
  \includegraphics[scale=0.66]{Graficos1.4/ban/PSO.png}
  \label{nombreparareferenciar11}
  \end{center}
\end{figure}

Y la varianza:

\begin{figure}[h!]
  \begin{center}
  \includegraphics[scale=0.66]{Graficos1.4/ban/VSO.png}
  \label{nombreparareferenciar12}
  \end{center}
\end{figure}

En este caso nuestro algoritmo supera ampliamente incluso al código C con mayor grado de optimización.


\section{Conclusiones y trabajo futuro}



\end{document}

